{"query": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"", "answer": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0", "result": "To implement the `correct_bracketing` function, we need to ensure that every opening bracket (`<`) has a matching closing bracket (`>`). We can track open brackets with a counter. Here is how you can implement it:\n\n```python\ndef correct_bracketing(brackets: str) -> bool:\n    \"\"\"Return True if every opening bracket has a corresponding closing bracket.\"\"\"\n\n    # Counter to track unmatched opening brackets\n    open_count = 0\n\n    for bracket in brackets:\n        if bracket == '<':\n            open_count += 1\n        elif bracket == '>':\n            open_count -= 1\n        \n        # If at any point the count goes negative, it means we encountered\n        # a closing bracket without a matching opening bracket\n        if open_count < 0:\n            return False\n    \n    # If open_count is zero, all opening brackets have been matched\n    return open_count == 0\n\n# Test cases\nprint(correct_bracketing(\"<\"))      # False\nprint(correct_bracketing(\"<>\"))     # True\nprint(correct_bracketing(\"<<><>>\")) # True\nprint(correct_bracketing(\"><<>\"))   # False\n```\n\n### Explanation:\n\n1. **Counter `open_count`**: We use a counter to keep track of unmatched opening brackets.\n\n2. **Iterate through each character**: \n   - If the character is an opening bracket `<`, we increment the counter.\n   - If it's a closing bracket `>`, we decrement the counter.\n\n3. **Check for unmatched closing brackets**: \n   - If at any iteration the counter becomes negative, it means there's a closing bracket without a prior opening match, and we immediately return `False`.\n\n4. **Final count check**:\n   - At the end of the traversal, if the counter is zero, it means every opening bracket had a matching closing bracket, so we return `True`. Otherwise, return `False`.", "tools": {}, "retrieve_time": [], "rerank_time": [], "communication_size": {}, "communication_pack": {}, "total_time": [15.874380111694336], "llm_time": {"gpt-4o-2024-08-06": [12.293959856033325]}, "llm_tokens": {"gpt-4o-2024-08-06": {"prompt": [924], "completion": [398], "total": [1322]}}}